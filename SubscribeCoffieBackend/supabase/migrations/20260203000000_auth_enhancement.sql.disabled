-- Auth enhancement: Full authentication with OAuth, email, and extended user profiles
-- Migration: 20260203000000_auth_enhancement.sql

-- Enable UUID extension if not already enabled
create extension if not exists "pgcrypto";

-- Extended user profiles table
-- This complements the existing profiles table with OAuth and auth-specific data
create table if not exists public.user_profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  
  -- User identity
  email text,
  phone text,
  full_name text,
  avatar_url text,
  
  -- Personal info (optional)
  birth_date date,
  city text,
  bio text,
  
  -- OAuth provider info
  auth_provider text not null default 'email',
  provider_id text,
  
  -- Preferences
  notification_enabled boolean not null default true,
  email_marketing_enabled boolean not null default false,
  push_marketing_enabled boolean not null default false,
  
  -- App preferences
  preferred_language text not null default 'ru',
  theme text not null default 'system',
  
  -- Account status
  is_verified boolean not null default false,
  is_active boolean not null default true,
  last_login_at timestamptz,
  
  -- Timestamps
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  
  constraint user_profiles_auth_provider_check check (auth_provider in ('email', 'google', 'apple', 'phone')),
  constraint user_profiles_theme_check check (theme in ('light', 'dark', 'system')),
  constraint user_profiles_language_check check (preferred_language in ('ru', 'en'))
);

-- Indexes for user_profiles
create index if not exists user_profiles_email_idx on public.user_profiles(email);
create index if not exists user_profiles_phone_idx on public.user_profiles(phone);
create index if not exists user_profiles_auth_provider_idx on public.user_profiles(auth_provider);
create index if not exists user_profiles_is_active_idx on public.user_profiles(is_active);

-- Trigger to update updated_at
drop trigger if exists set_user_profiles_updated_at on public.user_profiles;
create trigger set_user_profiles_updated_at 
  before update on public.user_profiles 
  for each row 
  execute function public.tg__update_timestamp();

-- OAuth connections table (for linking multiple providers)
create table if not exists public.oauth_connections (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  
  provider text not null,
  provider_user_id text not null,
  provider_email text,
  provider_data jsonb,
  
  is_primary boolean not null default false,
  
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  
  constraint oauth_connections_provider_check check (provider in ('google', 'apple', 'facebook', 'github')),
  unique(provider, provider_user_id)
);

-- Indexes for oauth_connections
create index if not exists oauth_connections_user_id_idx on public.oauth_connections(user_id);
create index if not exists oauth_connections_provider_idx on public.oauth_connections(provider);

-- Login history for security audit
create table if not exists public.login_history (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  
  login_method text not null,
  ip_address text,
  user_agent text,
  device_info jsonb,
  
  success boolean not null,
  failure_reason text,
  
  created_at timestamptz not null default now(),
  
  constraint login_history_method_check check (login_method in ('email', 'google', 'apple', 'phone', 'magic_link'))
);

-- Indexes for login_history
create index if not exists login_history_user_id_idx on public.login_history(user_id);
create index if not exists login_history_created_at_idx on public.login_history(created_at desc);

-- Account deletion requests (GDPR compliance)
create table if not exists public.account_deletion_requests (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  
  reason text,
  status text not null default 'pending',
  
  requested_at timestamptz not null default now(),
  processed_at timestamptz,
  processed_by uuid references auth.users(id),
  
  constraint account_deletion_status_check check (status in ('pending', 'approved', 'rejected', 'completed'))
);

-- RLS Policies for user_profiles
alter table public.user_profiles enable row level security;

-- Users can read their own profile
drop policy if exists "Users can view own profile" on public.user_profiles;
create policy "Users can view own profile" 
  on public.user_profiles 
  for select 
  using (auth.uid() = id);

-- Users can update their own profile
drop policy if exists "Users can update own profile" on public.user_profiles;
create policy "Users can update own profile" 
  on public.user_profiles 
  for update 
  using (auth.uid() = id);

-- Users can insert their own profile
drop policy if exists "Users can insert own profile" on public.user_profiles;
create policy "Users can insert own profile" 
  on public.user_profiles 
  for insert 
  with check (auth.uid() = id);

-- Admins can view all profiles
drop policy if exists "Admins can view all profiles" on public.user_profiles;
create policy "Admins can view all profiles" 
  on public.user_profiles 
  for select 
  using (
    exists (
      select 1 from public.profiles 
      where id = auth.uid() 
      and (role = 'admin' or role = 'superadmin')
    )
  );

-- RLS Policies for oauth_connections
alter table public.oauth_connections enable row level security;

drop policy if exists "Users can view own oauth connections" on public.oauth_connections;
create policy "Users can view own oauth connections" 
  on public.oauth_connections 
  for select 
  using (auth.uid() = user_id);

drop policy if exists "Users can manage own oauth connections" on public.oauth_connections;
create policy "Users can manage own oauth connections" 
  on public.oauth_connections 
  for all 
  using (auth.uid() = user_id);

-- RLS Policies for login_history
alter table public.login_history enable row level security;

drop policy if exists "Users can view own login history" on public.login_history;
create policy "Users can view own login history" 
  on public.login_history 
  for select 
  using (auth.uid() = user_id);

-- System can insert login history
drop policy if exists "System can insert login history" on public.login_history;
create policy "System can insert login history" 
  on public.login_history 
  for insert 
  with check (true);

-- RLS Policies for account_deletion_requests
alter table public.account_deletion_requests enable row level security;

drop policy if exists "Users can view own deletion requests" on public.account_deletion_requests;
create policy "Users can view own deletion requests" 
  on public.account_deletion_requests 
  for select 
  using (auth.uid() = user_id);

drop policy if exists "Users can create deletion requests" on public.account_deletion_requests;
create policy "Users can create deletion requests" 
  on public.account_deletion_requests 
  for insert 
  with check (auth.uid() = user_id);

-- Admins can manage deletion requests
drop policy if exists "Admins can manage deletion requests" on public.account_deletion_requests;
create policy "Admins can manage deletion requests" 
  on public.account_deletion_requests 
  for all 
  using (
    exists (
      select 1 from public.profiles 
      where id = auth.uid() 
      and (role = 'admin' or role = 'superadmin')
    )
  );

-- =====================================================
-- RPC Functions for Auth Management
-- =====================================================

-- Function: Create or update user profile after auth
create or replace function public.handle_new_user_profile()
returns trigger
language plpgsql
security definer
as $$
declare
  v_provider text;
  v_email text;
  v_phone text;
  v_full_name text;
  v_avatar_url text;
begin
  -- Extract data from auth.users metadata
  v_email := new.email;
  v_phone := new.phone;
  v_full_name := coalesce(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name', '');
  v_avatar_url := new.raw_user_meta_data->>'avatar_url';
  
  -- Determine provider
  if new.raw_app_meta_data->>'provider' = 'google' then
    v_provider := 'google';
  elsif new.raw_app_meta_data->>'provider' = 'apple' then
    v_provider := 'apple';
  elsif new.phone is not null then
    v_provider := 'phone';
  else
    v_provider := 'email';
  end if;
  
  -- Insert or update user_profiles
  insert into public.user_profiles (
    id, 
    email, 
    phone, 
    full_name, 
    avatar_url, 
    auth_provider,
    is_verified,
    last_login_at
  ) values (
    new.id,
    v_email,
    v_phone,
    v_full_name,
    v_avatar_url,
    v_provider,
    new.email_confirmed_at is not null or new.phone_confirmed_at is not null,
    now()
  )
  on conflict (id) do update set
    email = coalesce(excluded.email, user_profiles.email),
    phone = coalesce(excluded.phone, user_profiles.phone),
    full_name = coalesce(nullif(excluded.full_name, ''), user_profiles.full_name),
    avatar_url = coalesce(excluded.avatar_url, user_profiles.avatar_url),
    is_verified = excluded.is_verified or user_profiles.is_verified,
    last_login_at = excluded.last_login_at,
    updated_at = now();
  
  return new;
end;
$$;

-- Trigger: Auto-create user profile on signup
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row
  execute function public.handle_new_user_profile();

-- Function: Get user profile with auth info
create or replace function public.get_user_profile(p_user_id uuid default null)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_user_id uuid;
  v_profile jsonb;
begin
  -- Use provided user_id or current user
  v_user_id := coalesce(p_user_id, auth.uid());
  
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;
  
  -- Check authorization: users can only view their own profile unless admin
  if p_user_id is not null and p_user_id != auth.uid() then
    if not exists (
      select 1 from public.profiles 
      where id = auth.uid() 
      and (role = 'admin' or role = 'superadmin')
    ) then
      raise exception 'Unauthorized';
    end if;
  end if;
  
  select jsonb_build_object(
    'id', up.id,
    'email', up.email,
    'phone', up.phone,
    'full_name', up.full_name,
    'avatar_url', up.avatar_url,
    'birth_date', up.birth_date,
    'city', up.city,
    'bio', up.bio,
    'auth_provider', up.auth_provider,
    'notification_enabled', up.notification_enabled,
    'email_marketing_enabled', up.email_marketing_enabled,
    'push_marketing_enabled', up.push_marketing_enabled,
    'preferred_language', up.preferred_language,
    'theme', up.theme,
    'is_verified', up.is_verified,
    'is_active', up.is_active,
    'last_login_at', up.last_login_at,
    'created_at', up.created_at,
    'updated_at', up.updated_at,
    'oauth_connections', (
      select jsonb_agg(
        jsonb_build_object(
          'provider', oc.provider,
          'provider_email', oc.provider_email,
          'is_primary', oc.is_primary,
          'created_at', oc.created_at
        )
      )
      from public.oauth_connections oc
      where oc.user_id = v_user_id
    )
  ) into v_profile
  from public.user_profiles up
  where up.id = v_user_id;
  
  return v_profile;
end;
$$;

-- Function: Update user profile
create or replace function public.update_user_profile(
  p_full_name text default null,
  p_birth_date date default null,
  p_city text default null,
  p_bio text default null,
  p_avatar_url text default null,
  p_notification_enabled boolean default null,
  p_email_marketing_enabled boolean default null,
  p_push_marketing_enabled boolean default null,
  p_preferred_language text default null,
  p_theme text default null
)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_user_id uuid;
  v_result jsonb;
begin
  v_user_id := auth.uid();
  
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;
  
  update public.user_profiles
  set
    full_name = coalesce(p_full_name, full_name),
    birth_date = coalesce(p_birth_date, birth_date),
    city = coalesce(p_city, city),
    bio = coalesce(p_bio, bio),
    avatar_url = coalesce(p_avatar_url, avatar_url),
    notification_enabled = coalesce(p_notification_enabled, notification_enabled),
    email_marketing_enabled = coalesce(p_email_marketing_enabled, email_marketing_enabled),
    push_marketing_enabled = coalesce(p_push_marketing_enabled, push_marketing_enabled),
    preferred_language = coalesce(p_preferred_language, preferred_language),
    theme = coalesce(p_theme, theme),
    updated_at = now()
  where id = v_user_id;
  
  -- Return updated profile
  select public.get_user_profile(v_user_id) into v_result;
  return v_result;
end;
$$;

-- Function: Record login attempt
create or replace function public.record_login_attempt(
  p_user_id uuid,
  p_login_method text,
  p_ip_address text default null,
  p_user_agent text default null,
  p_device_info jsonb default null,
  p_success boolean default true,
  p_failure_reason text default null
)
returns uuid
language plpgsql
security definer
as $$
declare
  v_login_id uuid;
begin
  insert into public.login_history (
    user_id,
    login_method,
    ip_address,
    user_agent,
    device_info,
    success,
    failure_reason
  ) values (
    p_user_id,
    p_login_method,
    p_ip_address,
    p_user_agent,
    p_device_info,
    p_success,
    p_failure_reason
  )
  returning id into v_login_id;
  
  -- Update last login time if successful
  if p_success then
    update public.user_profiles
    set last_login_at = now()
    where id = p_user_id;
  end if;
  
  return v_login_id;
end;
$$;

-- Function: Get user login history
create or replace function public.get_login_history(
  p_limit int default 10,
  p_offset int default 0
)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_user_id uuid;
  v_result jsonb;
begin
  v_user_id := auth.uid();
  
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;
  
  select jsonb_agg(
    jsonb_build_object(
      'id', lh.id,
      'login_method', lh.login_method,
      'ip_address', lh.ip_address,
      'user_agent', lh.user_agent,
      'device_info', lh.device_info,
      'success', lh.success,
      'failure_reason', lh.failure_reason,
      'created_at', lh.created_at
    )
    order by lh.created_at desc
  ) into v_result
  from public.login_history lh
  where lh.user_id = v_user_id
  limit p_limit
  offset p_offset;
  
  return coalesce(v_result, '[]'::jsonb);
end;
$$;

-- Function: Request account deletion
create or replace function public.request_account_deletion(
  p_reason text default null
)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_user_id uuid;
  v_request_id uuid;
begin
  v_user_id := auth.uid();
  
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;
  
  -- Check if there's already a pending request
  if exists (
    select 1 from public.account_deletion_requests
    where user_id = v_user_id
    and status = 'pending'
  ) then
    raise exception 'Account deletion request already pending';
  end if;
  
  insert into public.account_deletion_requests (
    user_id,
    reason,
    status
  ) values (
    v_user_id,
    p_reason,
    'pending'
  )
  returning id into v_request_id;
  
  return jsonb_build_object(
    'request_id', v_request_id,
    'status', 'pending',
    'message', 'Your account deletion request has been submitted'
  );
end;
$$;

-- Function: Link OAuth provider
create or replace function public.link_oauth_provider(
  p_provider text,
  p_provider_user_id text,
  p_provider_email text default null,
  p_provider_data jsonb default null,
  p_is_primary boolean default false
)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_user_id uuid;
  v_connection_id uuid;
begin
  v_user_id := auth.uid();
  
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;
  
  -- If setting as primary, unset other primary connections
  if p_is_primary then
    update public.oauth_connections
    set is_primary = false
    where user_id = v_user_id;
  end if;
  
  insert into public.oauth_connections (
    user_id,
    provider,
    provider_user_id,
    provider_email,
    provider_data,
    is_primary
  ) values (
    v_user_id,
    p_provider,
    p_provider_user_id,
    p_provider_email,
    p_provider_data,
    p_is_primary
  )
  on conflict (provider, provider_user_id) do update set
    provider_email = excluded.provider_email,
    provider_data = excluded.provider_data,
    is_primary = excluded.is_primary,
    updated_at = now()
  returning id into v_connection_id;
  
  return jsonb_build_object(
    'connection_id', v_connection_id,
    'provider', p_provider,
    'success', true
  );
end;
$$;

-- Function: Unlink OAuth provider
create or replace function public.unlink_oauth_provider(
  p_provider text
)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_user_id uuid;
  v_deleted_count int;
begin
  v_user_id := auth.uid();
  
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;
  
  -- Prevent unlinking if it's the only auth method
  if (
    select count(*) from public.oauth_connections
    where user_id = v_user_id
  ) <= 1 and (
    select email is null and phone is null 
    from public.user_profiles 
    where id = v_user_id
  ) then
    raise exception 'Cannot unlink the only authentication method';
  end if;
  
  delete from public.oauth_connections
  where user_id = v_user_id
  and provider = p_provider;
  
  get diagnostics v_deleted_count = row_count;
  
  return jsonb_build_object(
    'provider', p_provider,
    'unlinked', v_deleted_count > 0
  );
end;
$$;

-- Grant necessary permissions
grant usage on schema public to anon, authenticated;
grant select, insert, update on public.user_profiles to authenticated;
grant select on public.user_profiles to anon;
grant select, insert, update, delete on public.oauth_connections to authenticated;
grant select, insert on public.login_history to authenticated;
grant select, insert on public.account_deletion_requests to authenticated;

grant execute on function public.get_user_profile to authenticated;
grant execute on function public.update_user_profile to authenticated;
grant execute on function public.record_login_attempt to anon, authenticated;
grant execute on function public.get_login_history to authenticated;
grant execute on function public.request_account_deletion to authenticated;
grant execute on function public.link_oauth_provider to authenticated;
grant execute on function public.unlink_oauth_provider to authenticated;

-- Comments for documentation
comment on table public.user_profiles is 'Extended user profiles with OAuth support';
comment on table public.oauth_connections is 'OAuth provider connections for users';
comment on table public.login_history is 'Login attempt history for security audit';
comment on table public.account_deletion_requests is 'GDPR-compliant account deletion requests';

comment on function public.get_user_profile is 'Get user profile with OAuth connections';
comment on function public.update_user_profile is 'Update user profile information';
comment on function public.record_login_attempt is 'Record login attempt for audit';
comment on function public.get_login_history is 'Get user login history';
comment on function public.request_account_deletion is 'Request account deletion (GDPR)';
comment on function public.link_oauth_provider is 'Link OAuth provider to user account';
comment on function public.unlink_oauth_provider is 'Unlink OAuth provider from user account';
