-- Migration: Delivery System and Couriers
-- Description: Implements delivery functionality with courier management and real-time tracking

-- ==============================================
-- TABLES
-- ==============================================

-- Couriers table
CREATE TABLE IF NOT EXISTS couriers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    phone TEXT NOT NULL,
    email TEXT,
    vehicle_type TEXT CHECK (vehicle_type IN ('bicycle', 'scooter', 'car', 'motorcycle', 'walk')) DEFAULT 'bicycle',
    status TEXT CHECK (status IN ('available', 'busy', 'offline', 'on_break')) DEFAULT 'offline',
    rating DECIMAL(3, 2) DEFAULT 5.00 CHECK (rating >= 0 AND rating <= 5),
    total_deliveries INTEGER DEFAULT 0,
    current_location GEOGRAPHY(POINT, 4326),
    last_location_update TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Courier locations history for tracking
CREATE TABLE IF NOT EXISTS courier_locations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    courier_id UUID REFERENCES couriers(id) ON DELETE CASCADE NOT NULL,
    location GEOGRAPHY(POINT, 4326) NOT NULL,
    accuracy DECIMAL(10, 2), -- in meters
    speed DECIMAL(10, 2), -- in meters per second
    heading DECIMAL(5, 2), -- in degrees
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Delivery orders table (extends regular orders)
CREATE TABLE IF NOT EXISTS delivery_orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID REFERENCES orders(id) ON DELETE CASCADE UNIQUE NOT NULL,
    courier_id UUID REFERENCES couriers(id) ON DELETE SET NULL,
    delivery_address TEXT NOT NULL,
    delivery_location GEOGRAPHY(POINT, 4326),
    delivery_instructions TEXT,
    delivery_fee_credits INTEGER NOT NULL DEFAULT 0,
    distance_km DECIMAL(10, 2), -- calculated distance
    estimated_delivery_time INTEGER, -- in minutes
    actual_delivery_time INTEGER, -- in minutes
    pickup_time TIMESTAMP WITH TIME ZONE,
    delivered_time TIMESTAMP WITH TIME ZONE,
    delivery_status TEXT CHECK (delivery_status IN (
        'pending_courier', 
        'assigned', 
        'courier_on_way_to_cafe', 
        'picked_up', 
        'on_way_to_customer', 
        'delivered', 
        'failed'
    )) DEFAULT 'pending_courier',
    customer_rating INTEGER CHECK (customer_rating >= 1 AND customer_rating <= 5),
    customer_feedback TEXT,
    courier_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Delivery zones (areas where delivery is available)
CREATE TABLE IF NOT EXISTS delivery_zones (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    cafe_id UUID REFERENCES cafes(id) ON DELETE CASCADE NOT NULL,
    zone_name TEXT NOT NULL,
    zone_polygon GEOGRAPHY(POLYGON, 4326) NOT NULL,
    base_delivery_fee_credits INTEGER NOT NULL DEFAULT 5000, -- 50 rubles in credits
    max_distance_km DECIMAL(10, 2) NOT NULL DEFAULT 5.0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Courier shifts for tracking working hours
CREATE TABLE IF NOT EXISTS courier_shifts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    courier_id UUID REFERENCES couriers(id) ON DELETE CASCADE NOT NULL,
    shift_start TIMESTAMP WITH TIME ZONE NOT NULL,
    shift_end TIMESTAMP WITH TIME ZONE,
    status TEXT CHECK (status IN ('active', 'completed', 'cancelled')) DEFAULT 'active',
    total_deliveries INTEGER DEFAULT 0,
    total_earnings_credits INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ==============================================
-- INDEXES
-- ==============================================

CREATE INDEX IF NOT EXISTS idx_couriers_status ON couriers(status) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_couriers_user_id ON couriers(user_id);
CREATE INDEX IF NOT EXISTS idx_couriers_location ON couriers USING GIST(current_location);

CREATE INDEX IF NOT EXISTS idx_courier_locations_courier_id ON courier_locations(courier_id);
CREATE INDEX IF NOT EXISTS idx_courier_locations_recorded_at ON courier_locations(recorded_at DESC);

CREATE INDEX IF NOT EXISTS idx_delivery_orders_order_id ON delivery_orders(order_id);
CREATE INDEX IF NOT EXISTS idx_delivery_orders_courier_id ON delivery_orders(courier_id);
CREATE INDEX IF NOT EXISTS idx_delivery_orders_status ON delivery_orders(delivery_status);
CREATE INDEX IF NOT EXISTS idx_delivery_orders_created_at ON delivery_orders(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_delivery_zones_cafe_id ON delivery_zones(cafe_id);
CREATE INDEX IF NOT EXISTS idx_delivery_zones_polygon ON delivery_zones USING GIST(zone_polygon);

CREATE INDEX IF NOT EXISTS idx_courier_shifts_courier_id ON courier_shifts(courier_id);
CREATE INDEX IF NOT EXISTS idx_courier_shifts_status ON courier_shifts(status);

-- ==============================================
-- TRIGGERS
-- ==============================================

-- Update timestamp trigger for couriers
CREATE OR REPLACE FUNCTION update_courier_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_courier_timestamp
    BEFORE UPDATE ON couriers
    FOR EACH ROW
    EXECUTE FUNCTION update_courier_timestamp();

-- Update timestamp trigger for delivery_orders
CREATE TRIGGER trigger_update_delivery_order_timestamp
    BEFORE UPDATE ON delivery_orders
    FOR EACH ROW
    EXECUTE FUNCTION update_courier_timestamp();

-- Update timestamp trigger for delivery_zones
CREATE TRIGGER trigger_update_delivery_zone_timestamp
    BEFORE UPDATE ON delivery_zones
    FOR EACH ROW
    EXECUTE FUNCTION update_courier_timestamp();

-- Update courier total deliveries when delivery is completed
CREATE OR REPLACE FUNCTION update_courier_stats()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.delivery_status = 'delivered' AND (OLD.delivery_status IS NULL OR OLD.delivery_status != 'delivered') THEN
        UPDATE couriers 
        SET 
            total_deliveries = total_deliveries + 1,
            status = 'available'
        WHERE id = NEW.courier_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_courier_stats
    AFTER UPDATE ON delivery_orders
    FOR EACH ROW
    EXECUTE FUNCTION update_courier_stats();

-- ==============================================
-- RPC FUNCTIONS
-- ==============================================

-- Calculate delivery fee based on distance and zone
CREATE OR REPLACE FUNCTION calculate_delivery_fee(
    p_cafe_id UUID,
    p_delivery_lat DECIMAL,
    p_delivery_lon DECIMAL
)
RETURNS JSON AS $$
DECLARE
    v_cafe_location GEOGRAPHY;
    v_distance_km DECIMAL;
    v_zone RECORD;
    v_base_fee INTEGER;
    v_distance_fee INTEGER;
    v_total_fee INTEGER;
    v_can_deliver BOOLEAN := false;
BEGIN
    -- Get cafe location
    SELECT location INTO v_cafe_location
    FROM cafes
    WHERE id = p_cafe_id;

    IF v_cafe_location IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Cafe not found'
        );
    END IF;

    -- Calculate distance
    v_distance_km := ST_Distance(
        v_cafe_location,
        ST_SetSRID(ST_MakePoint(p_delivery_lon, p_delivery_lat), 4326)::geography
    ) / 1000.0;

    -- Check if location is in any delivery zone
    SELECT * INTO v_zone
    FROM delivery_zones
    WHERE cafe_id = p_cafe_id
        AND is_active = true
        AND ST_Contains(
            zone_polygon::geometry,
            ST_SetSRID(ST_MakePoint(p_delivery_lon, p_delivery_lat), 4326)
        )
        AND v_distance_km <= max_distance_km
    LIMIT 1;

    IF FOUND THEN
        v_can_deliver := true;
        v_base_fee := v_zone.base_delivery_fee_credits;
        
        -- Additional fee for distance beyond 2km: 500 credits per km
        IF v_distance_km > 2.0 THEN
            v_distance_fee := ((v_distance_km - 2.0) * 500)::INTEGER;
        ELSE
            v_distance_fee := 0;
        END IF;
        
        v_total_fee := v_base_fee + v_distance_fee;
    ELSE
        v_total_fee := 0;
    END IF;

    RETURN json_build_object(
        'success', true,
        'can_deliver', v_can_deliver,
        'distance_km', ROUND(v_distance_km, 2),
        'base_fee', COALESCE(v_base_fee, 0),
        'distance_fee', COALESCE(v_distance_fee, 0),
        'total_fee', v_total_fee,
        'estimated_time', CASE 
            WHEN v_can_deliver THEN (v_distance_km * 5 + 15)::INTEGER -- 5 min per km + 15 min prep
            ELSE NULL 
        END
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create delivery order
CREATE OR REPLACE FUNCTION create_delivery_order(
    p_order_id UUID,
    p_delivery_address TEXT,
    p_delivery_lat DECIMAL,
    p_delivery_lon DECIMAL,
    p_delivery_instructions TEXT DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
    v_order RECORD;
    v_fee_info JSON;
    v_delivery_id UUID;
BEGIN
    -- Get order details
    SELECT * INTO v_order
    FROM orders
    WHERE id = p_order_id;

    IF NOT FOUND THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Order not found'
        );
    END IF;

    -- Calculate delivery fee
    v_fee_info := calculate_delivery_fee(
        v_order.cafe_id,
        p_delivery_lat,
        p_delivery_lon
    );

    IF NOT (v_fee_info->>'can_deliver')::BOOLEAN THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Delivery not available for this location'
        );
    END IF;

    -- Create delivery order
    INSERT INTO delivery_orders (
        order_id,
        delivery_address,
        delivery_location,
        delivery_instructions,
        delivery_fee_credits,
        distance_km,
        estimated_delivery_time
    ) VALUES (
        p_order_id,
        p_delivery_address,
        ST_SetSRID(ST_MakePoint(p_delivery_lon, p_delivery_lat), 4326)::geography,
        p_delivery_instructions,
        (v_fee_info->>'total_fee')::INTEGER,
        (v_fee_info->>'distance_km')::DECIMAL,
        (v_fee_info->>'estimated_time')::INTEGER
    )
    RETURNING id INTO v_delivery_id;

    RETURN json_build_object(
        'success', true,
        'delivery_id', v_delivery_id,
        'delivery_fee', (v_fee_info->>'total_fee')::INTEGER,
        'estimated_time', (v_fee_info->>'estimated_time')::INTEGER
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Assign courier to delivery order (automatic or manual)
CREATE OR REPLACE FUNCTION assign_courier_to_order(
    p_delivery_order_id UUID,
    p_courier_id UUID DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
    v_delivery RECORD;
    v_cafe_location GEOGRAPHY;
    v_assigned_courier_id UUID;
    v_courier RECORD;
BEGIN
    -- Get delivery order details
    SELECT 
        do.*,
        o.cafe_id
    INTO v_delivery
    FROM delivery_orders do
    JOIN orders o ON o.id = do.order_id
    WHERE do.id = p_delivery_order_id;

    IF NOT FOUND THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Delivery order not found'
        );
    END IF;

    IF v_delivery.delivery_status NOT IN ('pending_courier', 'assigned') THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Order is not in a state to assign courier'
        );
    END IF;

    -- Get cafe location
    SELECT location INTO v_cafe_location
    FROM cafes
    WHERE id = v_delivery.cafe_id;

    -- If no courier specified, find available one nearby
    IF p_courier_id IS NULL THEN
        SELECT id INTO v_assigned_courier_id
        FROM couriers
        WHERE status = 'available'
            AND is_active = true
            AND current_location IS NOT NULL
        ORDER BY ST_Distance(current_location, v_cafe_location)
        LIMIT 1;

        IF v_assigned_courier_id IS NULL THEN
            RETURN json_build_object(
                'success', false,
                'error', 'No available couriers found'
            );
        END IF;
    ELSE
        v_assigned_courier_id := p_courier_id;
        
        -- Verify courier is available
        SELECT * INTO v_courier
        FROM couriers
        WHERE id = v_assigned_courier_id
            AND is_active = true;

        IF NOT FOUND THEN
            RETURN json_build_object(
                'success', false,
                'error', 'Courier not found or not active'
            );
        END IF;
    END IF;

    -- Assign courier
    UPDATE delivery_orders
    SET 
        courier_id = v_assigned_courier_id,
        delivery_status = 'assigned',
        updated_at = NOW()
    WHERE id = p_delivery_order_id;

    -- Update courier status
    UPDATE couriers
    SET 
        status = 'busy',
        updated_at = NOW()
    WHERE id = v_assigned_courier_id;

    RETURN json_build_object(
        'success', true,
        'courier_id', v_assigned_courier_id,
        'message', 'Courier assigned successfully'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update courier location
CREATE OR REPLACE FUNCTION update_courier_location(
    p_courier_id UUID,
    p_lat DECIMAL,
    p_lon DECIMAL,
    p_accuracy DECIMAL DEFAULT NULL,
    p_speed DECIMAL DEFAULT NULL,
    p_heading DECIMAL DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
    v_location GEOGRAPHY;
BEGIN
    v_location := ST_SetSRID(ST_MakePoint(p_lon, p_lat), 4326)::geography;

    -- Update courier's current location
    UPDATE couriers
    SET 
        current_location = v_location,
        last_location_update = NOW(),
        updated_at = NOW()
    WHERE id = p_courier_id;

    IF NOT FOUND THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Courier not found'
        );
    END IF;

    -- Insert into location history
    INSERT INTO courier_locations (
        courier_id,
        location,
        accuracy,
        speed,
        heading
    ) VALUES (
        p_courier_id,
        v_location,
        p_accuracy,
        p_speed,
        p_heading
    );

    RETURN json_build_object(
        'success', true,
        'message', 'Location updated successfully'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get available couriers near location
CREATE OR REPLACE FUNCTION get_available_couriers(
    p_lat DECIMAL,
    p_lon DECIMAL,
    p_radius_km DECIMAL DEFAULT 5.0
)
RETURNS TABLE (
    courier_id UUID,
    first_name TEXT,
    last_name TEXT,
    phone TEXT,
    vehicle_type TEXT,
    rating DECIMAL,
    total_deliveries INTEGER,
    distance_km DECIMAL,
    last_update TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id,
        c.first_name,
        c.last_name,
        c.phone,
        c.vehicle_type,
        c.rating,
        c.total_deliveries,
        ROUND((ST_Distance(
            c.current_location,
            ST_SetSRID(ST_MakePoint(p_lon, p_lat), 4326)::geography
        ) / 1000.0)::NUMERIC, 2) as distance_km,
        c.last_location_update
    FROM couriers c
    WHERE c.status = 'available'
        AND c.is_active = true
        AND c.current_location IS NOT NULL
        AND ST_DWithin(
            c.current_location,
            ST_SetSRID(ST_MakePoint(p_lon, p_lat), 4326)::geography,
            p_radius_km * 1000
        )
    ORDER BY distance_km;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update delivery status
CREATE OR REPLACE FUNCTION update_delivery_status(
    p_delivery_order_id UUID,
    p_new_status TEXT,
    p_courier_notes TEXT DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
    v_current_status TEXT;
BEGIN
    -- Get current status
    SELECT delivery_status INTO v_current_status
    FROM delivery_orders
    WHERE id = p_delivery_order_id;

    IF NOT FOUND THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Delivery order not found'
        );
    END IF;

    -- Update status with special handling for certain transitions
    UPDATE delivery_orders
    SET 
        delivery_status = p_new_status,
        courier_notes = COALESCE(p_courier_notes, courier_notes),
        pickup_time = CASE 
            WHEN p_new_status = 'picked_up' THEN NOW()
            ELSE pickup_time
        END,
        delivered_time = CASE 
            WHEN p_new_status = 'delivered' THEN NOW()
            ELSE delivered_time
        END,
        actual_delivery_time = CASE
            WHEN p_new_status = 'delivered' THEN 
                EXTRACT(EPOCH FROM (NOW() - created_at)) / 60
            ELSE actual_delivery_time
        END,
        updated_at = NOW()
    WHERE id = p_delivery_order_id;

    -- Update related order status
    IF p_new_status = 'delivered' THEN
        UPDATE orders
        SET status = 'completed'
        WHERE id = (SELECT order_id FROM delivery_orders WHERE id = p_delivery_order_id);
    END IF;

    RETURN json_build_object(
        'success', true,
        'message', 'Status updated successfully',
        'new_status', p_new_status
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get courier current deliveries
CREATE OR REPLACE FUNCTION get_courier_deliveries(
    p_courier_id UUID,
    p_include_completed BOOLEAN DEFAULT false
)
RETURNS TABLE (
    delivery_id UUID,
    order_id UUID,
    cafe_name TEXT,
    cafe_address TEXT,
    cafe_lat DECIMAL,
    cafe_lon DECIMAL,
    delivery_address TEXT,
    delivery_lat DECIMAL,
    delivery_lon DECIMAL,
    delivery_status TEXT,
    estimated_time INTEGER,
    customer_phone TEXT,
    delivery_instructions TEXT,
    order_total INTEGER,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        do.id,
        do.order_id,
        c.name,
        c.address,
        ST_Y(c.location::geometry)::DECIMAL,
        ST_X(c.location::geometry)::DECIMAL,
        do.delivery_address,
        ST_Y(do.delivery_location::geometry)::DECIMAL,
        ST_X(do.delivery_location::geometry)::DECIMAL,
        do.delivery_status,
        do.estimated_delivery_time,
        u.phone,
        do.delivery_instructions,
        o.total_price_credits,
        do.created_at
    FROM delivery_orders do
    JOIN orders o ON o.id = do.order_id
    JOIN cafes c ON c.id = o.cafe_id
    JOIN users u ON u.id = o.user_id
    WHERE do.courier_id = p_courier_id
        AND (
            p_include_completed 
            OR do.delivery_status NOT IN ('delivered', 'failed')
        )
    ORDER BY 
        CASE do.delivery_status
            WHEN 'picked_up' THEN 1
            WHEN 'on_way_to_customer' THEN 2
            WHEN 'courier_on_way_to_cafe' THEN 3
            WHEN 'assigned' THEN 4
            ELSE 5
        END,
        do.created_at;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Start courier shift
CREATE OR REPLACE FUNCTION start_courier_shift(
    p_courier_id UUID
)
RETURNS JSON AS $$
DECLARE
    v_shift_id UUID;
    v_active_shift UUID;
BEGIN
    -- Check if courier already has an active shift
    SELECT id INTO v_active_shift
    FROM courier_shifts
    WHERE courier_id = p_courier_id
        AND status = 'active'
    LIMIT 1;

    IF v_active_shift IS NOT NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Courier already has an active shift'
        );
    END IF;

    -- Create new shift
    INSERT INTO courier_shifts (
        courier_id,
        shift_start
    ) VALUES (
        p_courier_id,
        NOW()
    )
    RETURNING id INTO v_shift_id;

    -- Update courier status
    UPDATE couriers
    SET status = 'available'
    WHERE id = p_courier_id;

    RETURN json_build_object(
        'success', true,
        'shift_id', v_shift_id,
        'message', 'Shift started successfully'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- End courier shift
CREATE OR REPLACE FUNCTION end_courier_shift(
    p_courier_id UUID
)
RETURNS JSON AS $$
DECLARE
    v_shift_id UUID;
    v_deliveries INTEGER;
BEGIN
    -- Get active shift
    SELECT id INTO v_shift_id
    FROM courier_shifts
    WHERE courier_id = p_courier_id
        AND status = 'active'
    LIMIT 1;

    IF v_shift_id IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'No active shift found'
        );
    END IF;

    -- Count deliveries during shift
    SELECT COUNT(*) INTO v_deliveries
    FROM delivery_orders
    WHERE courier_id = p_courier_id
        AND delivery_status = 'delivered'
        AND delivered_time >= (
            SELECT shift_start FROM courier_shifts WHERE id = v_shift_id
        );

    -- End shift
    UPDATE courier_shifts
    SET 
        shift_end = NOW(),
        status = 'completed',
        total_deliveries = v_deliveries
    WHERE id = v_shift_id;

    -- Update courier status
    UPDATE couriers
    SET status = 'offline'
    WHERE id = p_courier_id;

    RETURN json_build_object(
        'success', true,
        'shift_id', v_shift_id,
        'total_deliveries', v_deliveries,
        'message', 'Shift ended successfully'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ==============================================
-- VIEWS
-- ==============================================

-- Active deliveries view
CREATE OR REPLACE VIEW active_deliveries AS
SELECT 
    do.id as delivery_id,
    do.order_id,
    o.cafe_id,
    c.name as cafe_name,
    do.courier_id,
    cour.first_name || ' ' || cour.last_name as courier_name,
    cour.phone as courier_phone,
    cour.vehicle_type,
    u.id as customer_id,
    u.phone as customer_phone,
    do.delivery_address,
    do.delivery_status,
    do.estimated_delivery_time,
    do.distance_km,
    do.delivery_fee_credits,
    o.total_price_credits as order_total,
    do.created_at,
    do.pickup_time,
    ST_Y(do.delivery_location::geometry) as delivery_lat,
    ST_X(do.delivery_location::geometry) as delivery_lon,
    ST_Y(cour.current_location::geometry) as courier_current_lat,
    ST_X(cour.current_location::geometry) as courier_current_lon,
    cour.last_location_update
FROM delivery_orders do
JOIN orders o ON o.id = do.order_id
JOIN cafes c ON c.id = o.cafe_id
JOIN users u ON u.id = o.user_id
LEFT JOIN couriers cour ON cour.id = do.courier_id
WHERE do.delivery_status NOT IN ('delivered', 'failed');

-- Courier performance view
CREATE OR REPLACE VIEW courier_performance AS
SELECT 
    c.id as courier_id,
    c.first_name || ' ' || c.last_name as courier_name,
    c.vehicle_type,
    c.status,
    c.rating,
    c.total_deliveries,
    COUNT(CASE WHEN do.delivery_status = 'delivered' THEN 1 END) as completed_deliveries_today,
    COUNT(CASE WHEN do.delivery_status = 'failed' THEN 1 END) as failed_deliveries_today,
    AVG(CASE WHEN do.delivery_status = 'delivered' THEN do.actual_delivery_time END) as avg_delivery_time_today,
    AVG(CASE WHEN do.delivery_status = 'delivered' THEN do.customer_rating END) as avg_rating_today,
    SUM(CASE WHEN do.delivery_status = 'delivered' THEN do.delivery_fee_credits * 0.7 END)::INTEGER as earnings_today
FROM couriers c
LEFT JOIN delivery_orders do ON do.courier_id = c.id 
    AND DATE(do.created_at) = CURRENT_DATE
WHERE c.is_active = true
GROUP BY c.id, c.first_name, c.last_name, c.vehicle_type, c.status, c.rating, c.total_deliveries;

-- ==============================================
-- RLS POLICIES
-- ==============================================

-- Enable RLS
ALTER TABLE couriers ENABLE ROW LEVEL SECURITY;
ALTER TABLE courier_locations ENABLE ROW LEVEL SECURITY;
ALTER TABLE delivery_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE delivery_zones ENABLE ROW LEVEL SECURITY;
ALTER TABLE courier_shifts ENABLE ROW LEVEL SECURITY;

-- Couriers: Own data + admins
CREATE POLICY "Couriers can view own data"
    ON couriers FOR SELECT
    USING (auth.uid() = user_id OR EXISTS (
        SELECT 1 FROM users WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    ));

CREATE POLICY "Admins can manage couriers"
    ON couriers FOR ALL
    USING (EXISTS (
        SELECT 1 FROM users WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    ));

CREATE POLICY "Couriers can update own data"
    ON couriers FOR UPDATE
    USING (auth.uid() = user_id);

-- Courier locations: Own data + admins
CREATE POLICY "Couriers can view own locations"
    ON courier_locations FOR SELECT
    USING (EXISTS (
        SELECT 1 FROM couriers WHERE id = courier_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM users WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    ));

CREATE POLICY "Couriers can insert own locations"
    ON courier_locations FOR INSERT
    WITH CHECK (EXISTS (
        SELECT 1 FROM couriers WHERE id = courier_id AND user_id = auth.uid()
    ));

-- Delivery orders: Customers can view their orders, couriers can view assigned, admins all
CREATE POLICY "Users can view own delivery orders"
    ON delivery_orders FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM orders o 
            WHERE o.id = order_id AND o.user_id = auth.uid()
        )
        OR EXISTS (
            SELECT 1 FROM couriers c 
            WHERE c.id = courier_id AND c.user_id = auth.uid()
        )
        OR EXISTS (
            SELECT 1 FROM users WHERE id = auth.uid() AND role IN ('admin', 'super_admin', 'cafe_owner')
        )
    );

CREATE POLICY "Admins can manage delivery orders"
    ON delivery_orders FOR ALL
    USING (EXISTS (
        SELECT 1 FROM users WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    ));

CREATE POLICY "Couriers can update assigned deliveries"
    ON delivery_orders FOR UPDATE
    USING (EXISTS (
        SELECT 1 FROM couriers c 
        WHERE c.id = courier_id AND c.user_id = auth.uid()
    ));

-- Delivery zones: Public read, admins manage
CREATE POLICY "Anyone can view active delivery zones"
    ON delivery_zones FOR SELECT
    USING (is_active = true);

CREATE POLICY "Admins can manage delivery zones"
    ON delivery_zones FOR ALL
    USING (EXISTS (
        SELECT 1 FROM users WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    ));

-- Courier shifts: Own data + admins
CREATE POLICY "Couriers can view own shifts"
    ON courier_shifts FOR SELECT
    USING (EXISTS (
        SELECT 1 FROM couriers WHERE id = courier_id AND user_id = auth.uid()
    ) OR EXISTS (
        SELECT 1 FROM users WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    ));

CREATE POLICY "Couriers can manage own shifts"
    ON courier_shifts FOR ALL
    USING (EXISTS (
        SELECT 1 FROM couriers WHERE id = courier_id AND user_id = auth.uid()
    ));

-- ==============================================
-- SAMPLE DATA (Optional - for testing)
-- ==============================================

-- Insert sample delivery zones for existing cafes
INSERT INTO delivery_zones (cafe_id, zone_name, zone_polygon, base_delivery_fee_credits, max_distance_km)
SELECT 
    id,
    'Zone 1 - City Center',
    ST_Buffer(location::geometry, 0.05)::geography, -- ~5km radius
    5000,
    5.0
FROM cafes
LIMIT 3
ON CONFLICT DO NOTHING;

COMMENT ON TABLE couriers IS 'Courier/delivery personnel information';
COMMENT ON TABLE courier_locations IS 'Real-time courier location tracking history';
COMMENT ON TABLE delivery_orders IS 'Orders that include delivery service';
COMMENT ON TABLE delivery_zones IS 'Geographic areas where delivery is available';
COMMENT ON TABLE courier_shifts IS 'Courier working shifts for tracking hours and earnings';
