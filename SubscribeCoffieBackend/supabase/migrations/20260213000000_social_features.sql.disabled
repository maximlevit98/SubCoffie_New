-- Migration: Social Features
-- Description: Add user reviews, favorites, friends, and shared orders functionality
-- Date: 2026-02-13

-- =====================================================
-- 1. USER REVIEWS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS user_reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  cafe_id UUID REFERENCES cafes(id) ON DELETE CASCADE,
  menu_item_id UUID REFERENCES menu_items(id) ON DELETE CASCADE,
  order_id UUID REFERENCES orders(id) ON DELETE SET NULL,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment TEXT,
  photos TEXT[], -- Array of photo URLs (stored in Supabase Storage)
  helpful_count INTEGER DEFAULT 0,
  is_verified_purchase BOOLEAN DEFAULT false, -- True if reviewed after actual order
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'hidden', 'deleted')),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  
  -- At least one of cafe_id or menu_item_id must be present
  CONSTRAINT review_target_check CHECK (
    cafe_id IS NOT NULL OR menu_item_id IS NOT NULL
  )
);

-- Indexes for reviews
CREATE INDEX idx_user_reviews_user_id ON user_reviews(user_id);
CREATE INDEX idx_user_reviews_cafe_id ON user_reviews(cafe_id) WHERE cafe_id IS NOT NULL;
CREATE INDEX idx_user_reviews_menu_item_id ON user_reviews(menu_item_id) WHERE menu_item_id IS NOT NULL;
CREATE INDEX idx_user_reviews_order_id ON user_reviews(order_id) WHERE order_id IS NOT NULL;
CREATE INDEX idx_user_reviews_rating ON user_reviews(rating);
CREATE INDEX idx_user_reviews_created_at ON user_reviews(created_at DESC);

-- =====================================================
-- 2. REVIEW HELPFULNESS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS review_helpfulness (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  review_id UUID NOT NULL REFERENCES user_reviews(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  is_helpful BOOLEAN NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  
  UNIQUE(review_id, user_id)
);

CREATE INDEX idx_review_helpfulness_review_id ON review_helpfulness(review_id);
CREATE INDEX idx_review_helpfulness_user_id ON review_helpfulness(user_id);

-- =====================================================
-- 3. USER FAVORITES TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS user_favorites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  cafe_id UUID REFERENCES cafes(id) ON DELETE CASCADE,
  menu_item_id UUID REFERENCES menu_items(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT now(),
  
  -- At least one of cafe_id or menu_item_id must be present
  CONSTRAINT favorite_target_check CHECK (
    cafe_id IS NOT NULL OR menu_item_id IS NOT NULL
  ),
  
  -- Prevent duplicate favorites
  UNIQUE(user_id, cafe_id, menu_item_id)
);

CREATE INDEX idx_user_favorites_user_id ON user_favorites(user_id);
CREATE INDEX idx_user_favorites_cafe_id ON user_favorites(cafe_id) WHERE cafe_id IS NOT NULL;
CREATE INDEX idx_user_favorites_menu_item_id ON user_favorites(menu_item_id) WHERE menu_item_id IS NOT NULL;

-- =====================================================
-- 4. USER FRIENDS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS user_friends (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  friend_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'blocked')),
  created_at TIMESTAMPTZ DEFAULT now(),
  accepted_at TIMESTAMPTZ,
  
  -- Prevent self-friending
  CONSTRAINT no_self_friend CHECK (user_id != friend_id),
  
  -- Prevent duplicate friend requests
  UNIQUE(user_id, friend_id)
);

CREATE INDEX idx_user_friends_user_id ON user_friends(user_id);
CREATE INDEX idx_user_friends_friend_id ON user_friends(friend_id);
CREATE INDEX idx_user_friends_status ON user_friends(status);

-- =====================================================
-- 5. SHARED ORDERS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS shared_orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  initiator_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  total_amount_credits INTEGER NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'cancelled')),
  created_at TIMESTAMPTZ DEFAULT now(),
  confirmed_at TIMESTAMPTZ
);

CREATE INDEX idx_shared_orders_order_id ON shared_orders(order_id);
CREATE INDEX idx_shared_orders_initiator_user_id ON shared_orders(initiator_user_id);
CREATE INDEX idx_shared_orders_status ON shared_orders(status);

-- =====================================================
-- 6. SHARED ORDER PARTICIPANTS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS shared_order_participants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shared_order_id UUID NOT NULL REFERENCES shared_orders(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  share_amount_credits INTEGER NOT NULL CHECK (share_amount_credits > 0),
  payment_status TEXT DEFAULT 'pending' CHECK (payment_status IN ('pending', 'paid', 'declined')),
  paid_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  
  UNIQUE(shared_order_id, user_id)
);

CREATE INDEX idx_shared_order_participants_shared_order_id ON shared_order_participants(shared_order_id);
CREATE INDEX idx_shared_order_participants_user_id ON shared_order_participants(user_id);
CREATE INDEX idx_shared_order_participants_payment_status ON shared_order_participants(payment_status);

-- =====================================================
-- 7. TRIGGERS FOR UPDATED_AT
-- =====================================================
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_user_reviews_updated_at
  BEFORE UPDATE ON user_reviews
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- 8. RPC: SUBMIT REVIEW
-- =====================================================
CREATE OR REPLACE FUNCTION submit_review(
  p_user_id UUID,
  p_cafe_id UUID DEFAULT NULL,
  p_menu_item_id UUID DEFAULT NULL,
  p_order_id UUID DEFAULT NULL,
  p_rating INTEGER,
  p_comment TEXT DEFAULT NULL,
  p_photos TEXT[] DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
  v_review_id UUID;
  v_is_verified BOOLEAN := false;
BEGIN
  -- Validation
  IF p_rating < 1 OR p_rating > 5 THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Rating must be between 1 and 5'
    );
  END IF;
  
  IF p_cafe_id IS NULL AND p_menu_item_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Either cafe_id or menu_item_id must be provided'
    );
  END IF;
  
  -- Check if this is a verified purchase
  IF p_order_id IS NOT NULL THEN
    -- Verify that the order belongs to the user and is completed
    IF EXISTS (
      SELECT 1 FROM orders 
      WHERE id = p_order_id 
        AND user_id = p_user_id 
        AND status = 'issued'
    ) THEN
      v_is_verified := true;
    END IF;
  END IF;
  
  -- Insert review
  INSERT INTO user_reviews (
    user_id,
    cafe_id,
    menu_item_id,
    order_id,
    rating,
    comment,
    photos,
    is_verified_purchase
  ) VALUES (
    p_user_id,
    p_cafe_id,
    p_menu_item_id,
    p_order_id,
    p_rating,
    p_comment,
    p_photos,
    v_is_verified
  )
  RETURNING id INTO v_review_id;
  
  RETURN json_build_object(
    'success', true,
    'review_id', v_review_id,
    'is_verified', v_is_verified
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 9. RPC: MARK REVIEW AS HELPFUL
-- =====================================================
CREATE OR REPLACE FUNCTION mark_review_helpful(
  p_review_id UUID,
  p_user_id UUID,
  p_is_helpful BOOLEAN
)
RETURNS JSON AS $$
DECLARE
  v_existing_vote BOOLEAN;
BEGIN
  -- Check if user already voted
  SELECT is_helpful INTO v_existing_vote
  FROM review_helpfulness
  WHERE review_id = p_review_id AND user_id = p_user_id;
  
  IF v_existing_vote IS NOT NULL THEN
    -- Update existing vote
    UPDATE review_helpfulness
    SET is_helpful = p_is_helpful
    WHERE review_id = p_review_id AND user_id = p_user_id;
    
    -- Update helpful count
    UPDATE user_reviews
    SET helpful_count = (
      SELECT COUNT(*) FROM review_helpfulness
      WHERE review_id = p_review_id AND is_helpful = true
    )
    WHERE id = p_review_id;
  ELSE
    -- Insert new vote
    INSERT INTO review_helpfulness (review_id, user_id, is_helpful)
    VALUES (p_review_id, p_user_id, p_is_helpful);
    
    -- Update helpful count
    IF p_is_helpful THEN
      UPDATE user_reviews
      SET helpful_count = helpful_count + 1
      WHERE id = p_review_id;
    END IF;
  END IF;
  
  RETURN json_build_object('success', true);
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 10. RPC: TOGGLE FAVORITE
-- =====================================================
CREATE OR REPLACE FUNCTION toggle_favorite(
  p_user_id UUID,
  p_cafe_id UUID DEFAULT NULL,
  p_menu_item_id UUID DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
  v_favorite_id UUID;
  v_is_favorited BOOLEAN;
BEGIN
  -- Validation
  IF p_cafe_id IS NULL AND p_menu_item_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Either cafe_id or menu_item_id must be provided'
    );
  END IF;
  
  -- Check if already favorited
  SELECT id INTO v_favorite_id
  FROM user_favorites
  WHERE user_id = p_user_id
    AND (cafe_id = p_cafe_id OR (p_cafe_id IS NULL AND cafe_id IS NULL))
    AND (menu_item_id = p_menu_item_id OR (p_menu_item_id IS NULL AND menu_item_id IS NULL));
  
  IF v_favorite_id IS NOT NULL THEN
    -- Remove favorite
    DELETE FROM user_favorites WHERE id = v_favorite_id;
    v_is_favorited := false;
  ELSE
    -- Add favorite
    INSERT INTO user_favorites (user_id, cafe_id, menu_item_id)
    VALUES (p_user_id, p_cafe_id, p_menu_item_id)
    RETURNING id INTO v_favorite_id;
    v_is_favorited := true;
  END IF;
  
  RETURN json_build_object(
    'success', true,
    'is_favorited', v_is_favorited,
    'favorite_id', v_favorite_id
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 11. RPC: GET USER FAVORITES
-- =====================================================
CREATE OR REPLACE FUNCTION get_user_favorites(
  p_user_id UUID,
  p_type TEXT DEFAULT 'all' -- 'all', 'cafes', 'menu_items'
)
RETURNS JSON AS $$
DECLARE
  v_result JSON;
BEGIN
  SELECT json_build_object(
    'cafes', (
      SELECT COALESCE(json_agg(json_build_object(
        'favorite_id', f.id,
        'cafe_id', c.id,
        'name', c.name,
        'address', c.address,
        'logo_url', c.logo_url,
        'favorited_at', f.created_at
      )), '[]'::json)
      FROM user_favorites f
      JOIN cafes c ON c.id = f.cafe_id
      WHERE f.user_id = p_user_id
        AND f.cafe_id IS NOT NULL
        AND (p_type = 'all' OR p_type = 'cafes')
    ),
    'menu_items', (
      SELECT COALESCE(json_agg(json_build_object(
        'favorite_id', f.id,
        'menu_item_id', m.id,
        'name', m.name,
        'description', m.description,
        'price_credits', m.price_credits,
        'image_url', m.image_url,
        'cafe_id', m.cafe_id,
        'favorited_at', f.created_at
      )), '[]'::json)
      FROM user_favorites f
      JOIN menu_items m ON m.id = f.menu_item_id
      WHERE f.user_id = p_user_id
        AND f.menu_item_id IS NOT NULL
        AND (p_type = 'all' OR p_type = 'menu_items')
    )
  ) INTO v_result;
  
  RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 12. RPC: SEND FRIEND REQUEST
-- =====================================================
CREATE OR REPLACE FUNCTION send_friend_request(
  p_user_id UUID,
  p_friend_id UUID
)
RETURNS JSON AS $$
DECLARE
  v_request_id UUID;
  v_existing_status TEXT;
BEGIN
  -- Validation
  IF p_user_id = p_friend_id THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Cannot send friend request to yourself'
    );
  END IF;
  
  -- Check if request already exists
  SELECT status INTO v_existing_status
  FROM user_friends
  WHERE (user_id = p_user_id AND friend_id = p_friend_id)
     OR (user_id = p_friend_id AND friend_id = p_user_id);
  
  IF v_existing_status IS NOT NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Friend request already exists with status: ' || v_existing_status
    );
  END IF;
  
  -- Create friend request
  INSERT INTO user_friends (user_id, friend_id, status)
  VALUES (p_user_id, p_friend_id, 'pending')
  RETURNING id INTO v_request_id;
  
  RETURN json_build_object(
    'success', true,
    'request_id', v_request_id
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 13. RPC: RESPOND TO FRIEND REQUEST
-- =====================================================
CREATE OR REPLACE FUNCTION respond_to_friend_request(
  p_request_id UUID,
  p_user_id UUID,
  p_accept BOOLEAN
)
RETURNS JSON AS $$
DECLARE
  v_request_user_id UUID;
  v_request_friend_id UUID;
BEGIN
  -- Get request details
  SELECT user_id, friend_id
  INTO v_request_user_id, v_request_friend_id
  FROM user_friends
  WHERE id = p_request_id AND status = 'pending';
  
  IF v_request_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Friend request not found or already processed'
    );
  END IF;
  
  -- Verify that p_user_id is the recipient
  IF v_request_friend_id != p_user_id THEN
    RETURN json_build_object(
      'success', false,
      'error', 'You are not the recipient of this friend request'
    );
  END IF;
  
  IF p_accept THEN
    -- Accept request
    UPDATE user_friends
    SET status = 'accepted', accepted_at = now()
    WHERE id = p_request_id;
    
    RETURN json_build_object(
      'success', true,
      'status', 'accepted'
    );
  ELSE
    -- Decline request
    DELETE FROM user_friends WHERE id = p_request_id;
    
    RETURN json_build_object(
      'success', true,
      'status', 'declined'
    );
  END IF;
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 14. RPC: GET USER FRIENDS
-- =====================================================
CREATE OR REPLACE FUNCTION get_user_friends(
  p_user_id UUID,
  p_status TEXT DEFAULT 'accepted' -- 'pending', 'accepted', 'all'
)
RETURNS JSON AS $$
BEGIN
  RETURN (
    SELECT COALESCE(json_agg(json_build_object(
      'friend_id', 
        CASE 
          WHEN f.user_id = p_user_id THEN f.friend_id
          ELSE f.user_id
        END,
      'request_id', f.id,
      'status', f.status,
      'is_initiator', f.user_id = p_user_id,
      'created_at', f.created_at,
      'accepted_at', f.accepted_at
    )), '[]'::json)
    FROM user_friends f
    WHERE (f.user_id = p_user_id OR f.friend_id = p_user_id)
      AND (p_status = 'all' OR f.status = p_status)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 15. RPC: CREATE SHARED ORDER
-- =====================================================
CREATE OR REPLACE FUNCTION create_shared_order(
  p_order_id UUID,
  p_initiator_user_id UUID,
  p_participants JSON -- [{"user_id": "uuid", "share_amount_credits": 100}]
)
RETURNS JSON AS $$
DECLARE
  v_shared_order_id UUID;
  v_total_amount INTEGER;
  v_order_amount INTEGER;
  v_participant JSON;
BEGIN
  -- Get order amount
  SELECT total_amount_credits INTO v_order_amount
  FROM orders
  WHERE id = p_order_id AND user_id = p_initiator_user_id;
  
  IF v_order_amount IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Order not found or you are not the owner'
    );
  END IF;
  
  -- Calculate total participant amounts
  SELECT SUM((participant->>'share_amount_credits')::INTEGER)
  INTO v_total_amount
  FROM json_array_elements(p_participants) AS participant;
  
  IF v_total_amount != v_order_amount THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Total share amounts must equal order amount'
    );
  END IF;
  
  -- Create shared order
  INSERT INTO shared_orders (order_id, initiator_user_id, total_amount_credits)
  VALUES (p_order_id, p_initiator_user_id, v_order_amount)
  RETURNING id INTO v_shared_order_id;
  
  -- Add participants
  FOR v_participant IN SELECT * FROM json_array_elements(p_participants)
  LOOP
    INSERT INTO shared_order_participants (
      shared_order_id,
      user_id,
      share_amount_credits
    ) VALUES (
      v_shared_order_id,
      (v_participant->>'user_id')::UUID,
      (v_participant->>'share_amount_credits')::INTEGER
    );
  END LOOP;
  
  RETURN json_build_object(
    'success', true,
    'shared_order_id', v_shared_order_id
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 16. RPC: PAY SHARE OF ORDER
-- =====================================================
CREATE OR REPLACE FUNCTION pay_shared_order_share(
  p_participant_id UUID,
  p_user_id UUID,
  p_wallet_id UUID
)
RETURNS JSON AS $$
DECLARE
  v_share_amount INTEGER;
  v_wallet_balance INTEGER;
  v_all_paid BOOLEAN;
  v_shared_order_id UUID;
BEGIN
  -- Get share amount and verify user
  SELECT share_amount_credits, shared_order_id
  INTO v_share_amount, v_shared_order_id
  FROM shared_order_participants
  WHERE id = p_participant_id
    AND user_id = p_user_id
    AND payment_status = 'pending';
  
  IF v_share_amount IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Participant not found or already paid'
    );
  END IF;
  
  -- Check wallet balance
  SELECT balance_credits INTO v_wallet_balance
  FROM wallets
  WHERE id = p_wallet_id AND user_id = p_user_id;
  
  IF v_wallet_balance IS NULL OR v_wallet_balance < v_share_amount THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Insufficient wallet balance'
    );
  END IF;
  
  -- Deduct from wallet
  UPDATE wallets
  SET balance_credits = balance_credits - v_share_amount
  WHERE id = p_wallet_id;
  
  -- Mark as paid
  UPDATE shared_order_participants
  SET payment_status = 'paid', paid_at = now()
  WHERE id = p_participant_id;
  
  -- Check if all participants paid
  SELECT NOT EXISTS (
    SELECT 1 FROM shared_order_participants
    WHERE shared_order_id = v_shared_order_id
      AND payment_status = 'pending'
  ) INTO v_all_paid;
  
  -- If all paid, mark shared order as confirmed
  IF v_all_paid THEN
    UPDATE shared_orders
    SET status = 'confirmed', confirmed_at = now()
    WHERE id = v_shared_order_id;
  END IF;
  
  RETURN json_build_object(
    'success', true,
    'all_paid', v_all_paid
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 17. RPC: GET CAFE REVIEWS
-- =====================================================
CREATE OR REPLACE FUNCTION get_cafe_reviews(
  p_cafe_id UUID,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
)
RETURNS JSON AS $$
BEGIN
  RETURN json_build_object(
    'reviews', (
      SELECT COALESCE(json_agg(json_build_object(
        'review_id', r.id,
        'user_id', r.user_id,
        'rating', r.rating,
        'comment', r.comment,
        'photos', r.photos,
        'helpful_count', r.helpful_count,
        'is_verified_purchase', r.is_verified_purchase,
        'created_at', r.created_at
      ) ORDER BY r.created_at DESC), '[]'::json)
      FROM user_reviews r
      WHERE r.cafe_id = p_cafe_id
        AND r.status = 'active'
      LIMIT p_limit
      OFFSET p_offset
    ),
    'average_rating', (
      SELECT ROUND(AVG(rating)::numeric, 2)
      FROM user_reviews
      WHERE cafe_id = p_cafe_id AND status = 'active'
    ),
    'total_reviews', (
      SELECT COUNT(*)
      FROM user_reviews
      WHERE cafe_id = p_cafe_id AND status = 'active'
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 18. ROW LEVEL SECURITY (RLS)
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE user_reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE review_helpfulness ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_favorites ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_friends ENABLE ROW LEVEL SECURITY;
ALTER TABLE shared_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE shared_order_participants ENABLE ROW LEVEL SECURITY;

-- RLS Policies for user_reviews
CREATE POLICY "Users can view active reviews"
  ON user_reviews FOR SELECT
  USING (status = 'active');

CREATE POLICY "Users can insert their own reviews"
  ON user_reviews FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own reviews"
  ON user_reviews FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own reviews"
  ON user_reviews FOR DELETE
  USING (auth.uid() = user_id);

-- RLS Policies for review_helpfulness
CREATE POLICY "Users can view all helpfulness votes"
  ON review_helpfulness FOR SELECT
  USING (true);

CREATE POLICY "Users can insert their own votes"
  ON review_helpfulness FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own votes"
  ON review_helpfulness FOR UPDATE
  USING (auth.uid() = user_id);

-- RLS Policies for user_favorites
CREATE POLICY "Users can view their own favorites"
  ON user_favorites FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own favorites"
  ON user_favorites FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own favorites"
  ON user_favorites FOR DELETE
  USING (auth.uid() = user_id);

-- RLS Policies for user_friends
CREATE POLICY "Users can view their own friend connections"
  ON user_friends FOR SELECT
  USING (auth.uid() = user_id OR auth.uid() = friend_id);

CREATE POLICY "Users can send friend requests"
  ON user_friends FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can respond to friend requests"
  ON user_friends FOR UPDATE
  USING (auth.uid() = friend_id);

CREATE POLICY "Users can delete their friend connections"
  ON user_friends FOR DELETE
  USING (auth.uid() = user_id OR auth.uid() = friend_id);

-- RLS Policies for shared_orders
CREATE POLICY "Users can view shared orders they're involved in"
  ON shared_orders FOR SELECT
  USING (
    auth.uid() = initiator_user_id
    OR EXISTS (
      SELECT 1 FROM shared_order_participants
      WHERE shared_order_id = id AND user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create shared orders for their orders"
  ON shared_orders FOR INSERT
  WITH CHECK (auth.uid() = initiator_user_id);

-- RLS Policies for shared_order_participants
CREATE POLICY "Users can view participants of shared orders they're in"
  ON shared_order_participants FOR SELECT
  USING (
    auth.uid() = user_id
    OR EXISTS (
      SELECT 1 FROM shared_orders
      WHERE id = shared_order_id AND initiator_user_id = auth.uid()
    )
  );

CREATE POLICY "Initiators can add participants"
  ON shared_order_participants FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM shared_orders
      WHERE id = shared_order_id AND initiator_user_id = auth.uid()
    )
  );

-- =====================================================
-- 19. VIEWS FOR ANALYTICS
-- =====================================================

-- View: Cafe ratings summary
CREATE OR REPLACE VIEW cafe_ratings_summary AS
SELECT
  c.id AS cafe_id,
  c.name AS cafe_name,
  COUNT(r.id) AS total_reviews,
  ROUND(AVG(r.rating)::numeric, 2) AS average_rating,
  COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_count,
  COUNT(CASE WHEN r.rating = 4 THEN 1 END) AS four_star_count,
  COUNT(CASE WHEN r.rating = 3 THEN 1 END) AS three_star_count,
  COUNT(CASE WHEN r.rating = 2 THEN 1 END) AS two_star_count,
  COUNT(CASE WHEN r.rating = 1 THEN 1 END) AS one_star_count
FROM cafes c
LEFT JOIN user_reviews r ON r.cafe_id = c.id AND r.status = 'active'
GROUP BY c.id, c.name;

-- View: Popular menu items by favorites
CREATE OR REPLACE VIEW popular_items_by_favorites AS
SELECT
  m.id AS menu_item_id,
  m.name AS item_name,
  m.cafe_id,
  c.name AS cafe_name,
  COUNT(f.id) AS favorite_count
FROM menu_items m
LEFT JOIN user_favorites f ON f.menu_item_id = m.id
LEFT JOIN cafes c ON c.id = m.cafe_id
WHERE m.is_available = true
GROUP BY m.id, m.name, m.cafe_id, c.name
ORDER BY favorite_count DESC;

-- =====================================================
-- 20. COMMENTS
-- =====================================================
COMMENT ON TABLE user_reviews IS 'User reviews for cafes and menu items';
COMMENT ON TABLE user_favorites IS 'User favorites for cafes and menu items';
COMMENT ON TABLE user_friends IS 'User friend connections';
COMMENT ON TABLE shared_orders IS 'Shared orders for group payments';
COMMENT ON TABLE shared_order_participants IS 'Participants in shared orders';

-- Migration complete
