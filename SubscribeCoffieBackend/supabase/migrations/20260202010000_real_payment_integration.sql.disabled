-- ⚠️ ⚠️ ⚠️ CRITICAL SECURITY NOTICE ⚠️ ⚠️ ⚠️
-- 
-- This migration is INTENTIONALLY DISABLED (.disabled extension)
-- 
-- DO NOT ENABLE without completing Pre-Production Checklist:
-- See: SubscribeCoffieBackend/PAYMENT_SECURITY.md
--
-- Required approvals before enabling:
-- [ ] Technical Lead - Security review
-- [ ] Product Owner - Business requirements  
-- [ ] Legal/Finance - Contracts & compliance
--
-- This migration adds REAL MONEY payment processing with:
-- - YooKassa integration (Russian market)
-- - Stripe integration (International)
-- - Webhook event processing
-- - Transaction confirmation/failure handling
--
-- Enabling this without proper setup will:
-- ❌ Expose payment provider credentials
-- ❌ Allow real money transactions
-- ❌ Require PCI DSS compliance
-- ❌ Need legal/contract setup
--
-- Current safe mode: mock payments (instant, no real money)
--
-- ⚠️ ⚠️ ⚠️ END SECURITY NOTICE ⚠️ ⚠️ ⚠️

-- Migration: Real Payment Integration (YooKassa + Stripe)
-- Description: Replaces mock payments with real payment provider integration
-- Date: 2026-02-02

-- ============================================================================
-- 1. Add payment provider configuration table
-- ============================================================================

create table if not exists public.payment_provider_config (
  id uuid primary key default gen_random_uuid(),
  provider_name text unique not null check (provider_name in ('yookassa', 'stripe')),
  is_active boolean default false,
  shop_id text, -- YooKassa shop ID or Stripe account ID
  api_key_encrypted text, -- Encrypted API key
  webhook_secret text, -- For webhook validation
  test_mode boolean default true,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

comment on table public.payment_provider_config is 'Configuration for payment providers (YooKassa, Stripe)';

-- Enable RLS
alter table public.payment_provider_config enable row level security;

-- Policies
create policy "Admin can manage payment provider config"
  on public.payment_provider_config for all
  using (
    exists (
      select 1 from public.profiles
      where id = auth.uid() and role = 'admin'
    )
  );

-- ============================================================================
-- 2. Update payment_methods table to support real provider tokens
-- ============================================================================

alter table public.payment_methods
  add column if not exists provider_payment_method_id text; -- YooKassa/Stripe payment method ID

comment on column public.payment_methods.provider_payment_method_id is 'Payment method ID from provider (e.g., pm_xxxx for Stripe)';

-- ============================================================================
-- 3. Update payment_transactions table for real payments
-- ============================================================================

alter table public.payment_transactions
  add column if not exists provider_payment_intent_id text, -- Payment intent ID from provider
  add column if not exists provider_error_code text, -- Error code from provider
  add column if not exists provider_error_message text, -- Error message from provider
  add column if not exists metadata jsonb; -- Additional metadata

comment on column public.payment_transactions.provider_payment_intent_id is 'Payment intent ID from provider (e.g., pi_xxxx for Stripe)';

-- Create index for provider payment intent lookup (for webhooks)
create index if not exists payment_transactions_provider_payment_intent_id_idx 
  on public.payment_transactions(provider_payment_intent_id);

-- ============================================================================
-- 4. Create webhook events log table
-- ============================================================================

create table if not exists public.payment_webhook_events (
  id uuid primary key default gen_random_uuid(),
  provider text not null check (provider in ('yookassa', 'stripe')),
  event_type text not null,
  event_id text unique not null, -- Provider's event ID
  payload jsonb not null,
  processed boolean default false,
  processing_error text,
  created_at timestamp with time zone default now(),
  processed_at timestamp with time zone
);

comment on table public.payment_webhook_events is 'Log of all webhook events from payment providers';

-- Enable RLS
alter table public.payment_webhook_events enable row level security;

-- Policies
create policy "Admin can view webhook events"
  on public.payment_webhook_events for select
  using (
    exists (
      select 1 from public.profiles
      where id = auth.uid() and role = 'admin'
    )
  );

-- Indexes
create index if not exists payment_webhook_events_provider_idx on public.payment_webhook_events(provider);
create index if not exists payment_webhook_events_processed_idx on public.payment_webhook_events(processed);
create index if not exists payment_webhook_events_created_at_idx on public.payment_webhook_events(created_at desc);

-- ============================================================================
-- 5. Helper function: Get active payment provider
-- ============================================================================

create or replace function public.get_active_payment_provider()
returns text
language plpgsql
security definer
as $$
declare
  v_provider text;
begin
  select provider_name into v_provider
  from public.payment_provider_config
  where is_active = true
  limit 1;
  
  return coalesce(v_provider, 'mock');
end;
$$;

comment on function public.get_active_payment_provider is 'Returns the active payment provider (yookassa/stripe/mock)';

-- ============================================================================
-- 6. Function: Create payment intent (initiates real payment)
-- ============================================================================

create or replace function public.create_payment_intent(
  p_wallet_id uuid,
  p_amount int,
  p_payment_method_id uuid default null,
  p_description text default 'Wallet Top-Up'
)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_user_id uuid;
  v_wallet_type wallet_type;
  v_commission int;
  v_amount_credited int;
  v_transaction_id uuid;
  v_provider text;
  v_provider_config jsonb;
begin
  -- Get wallet info
  select user_id, wallet_type into v_user_id, v_wallet_type
  from public.wallets
  where id = p_wallet_id;

  if v_user_id is null then
    raise exception 'Wallet not found';
  end if;
  
  -- Check user authorization
  if auth.uid() != v_user_id then
    raise exception 'Unauthorized';
  end if;

  -- Calculate commission
  v_commission := public.calculate_commission(p_amount, 'topup', v_wallet_type);
  v_amount_credited := p_amount - v_commission;

  -- Get active payment provider
  v_provider := public.get_active_payment_provider();
  
  -- Get provider configuration
  select jsonb_build_object(
    'provider_name', provider_name,
    'shop_id', shop_id,
    'test_mode', test_mode
  ) into v_provider_config
  from public.payment_provider_config
  where provider_name = v_provider and is_active = true;

  -- Create transaction record with pending status
  insert into public.payment_transactions (
    user_id, wallet_id, amount_credits, commission_credits,
    transaction_type, payment_method_id, status,
    metadata
  )
  values (
    v_user_id, p_wallet_id, p_amount, v_commission,
    'topup', p_payment_method_id, 'pending',
    jsonb_build_object(
      'description', p_description,
      'provider', v_provider
    )
  )
  returning id into v_transaction_id;

  -- Return payment intent info (client will complete payment with provider SDK)
  return jsonb_build_object(
    'success', true,
    'transaction_id', v_transaction_id,
    'amount', p_amount,
    'commission', v_commission,
    'amount_credited', v_amount_credited,
    'provider', v_provider,
    'provider_config', v_provider_config,
    'client_secret', null -- Will be generated by Edge Function
  );
end;
$$;

comment on function public.create_payment_intent is 'Creates a payment intent for wallet top-up (real payment)';

-- ============================================================================
-- 7. Function: Confirm payment (called by webhook or client)
-- ============================================================================

create or replace function public.confirm_payment(
  p_transaction_id uuid,
  p_provider_transaction_id text,
  p_provider_payment_intent_id text default null
)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_wallet_id uuid;
  v_amount_credited int;
  v_commission int;
  v_status text;
begin
  -- Get transaction info
  select wallet_id, (amount_credits - commission_credits), commission_credits, status
  into v_wallet_id, v_amount_credited, v_commission, v_status
  from public.payment_transactions
  where id = p_transaction_id;

  if v_wallet_id is null then
    raise exception 'Transaction not found';
  end if;

  if v_status = 'completed' then
    raise exception 'Transaction already completed';
  end if;

  -- Update transaction to completed
  update public.payment_transactions
  set
    status = 'completed',
    provider_transaction_id = p_provider_transaction_id,
    provider_payment_intent_id = p_provider_payment_intent_id,
    completed_at = now()
  where id = p_transaction_id;

  -- Update wallet balance
  update public.wallets
  set
    balance_credits = balance_credits + v_amount_credited,
    lifetime_top_up_credits = lifetime_top_up_credits + v_amount_credited,
    updated_at = now()
  where id = v_wallet_id;
  
  -- Log transaction to wallet_transactions
  insert into public.wallet_transactions (wallet_id, direction, amount, reason)
  values (v_wallet_id, 'credit', v_amount_credited, 'Top-up payment confirmed');

  return jsonb_build_object(
    'success', true,
    'transaction_id', p_transaction_id,
    'amount_credited', v_amount_credited,
    'status', 'completed'
  );
end;
$$;

comment on function public.confirm_payment is 'Confirms a payment and credits wallet (called by webhook)';

-- ============================================================================
-- 8. Function: Fail payment (called by webhook)
-- ============================================================================

create or replace function public.fail_payment(
  p_transaction_id uuid,
  p_error_code text default null,
  p_error_message text default null
)
returns jsonb
language plpgsql
security definer
as $$
begin
  -- Update transaction to failed
  update public.payment_transactions
  set
    status = 'failed',
    provider_error_code = p_error_code,
    provider_error_message = p_error_message,
    completed_at = now()
  where id = p_transaction_id;

  return jsonb_build_object(
    'success', true,
    'transaction_id', p_transaction_id,
    'status', 'failed'
  );
end;
$$;

comment on function public.fail_payment is 'Marks a payment as failed (called by webhook)';

-- ============================================================================
-- 9. Function: Process webhook event
-- ============================================================================

create or replace function public.process_webhook_event(
  p_provider text,
  p_event_type text,
  p_event_id text,
  p_payload jsonb
)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_webhook_id uuid;
  v_already_processed boolean;
  v_result jsonb;
begin
  -- Check if event already processed
  select id, processed into v_webhook_id, v_already_processed
  from public.payment_webhook_events
  where event_id = p_event_id;

  if v_already_processed then
    return jsonb_build_object(
      'success', true,
      'message', 'Event already processed',
      'webhook_id', v_webhook_id
    );
  end if;

  -- Insert or update webhook event
  insert into public.payment_webhook_events (provider, event_type, event_id, payload)
  values (p_provider, p_event_type, p_event_id, p_payload)
  on conflict (event_id) do update
  set processed = false, created_at = now()
  returning id into v_webhook_id;

  -- Process based on event type
  -- Note: Actual processing logic will be in Edge Function
  -- This function just logs the event

  update public.payment_webhook_events
  set processed = true, processed_at = now()
  where id = v_webhook_id;

  return jsonb_build_object(
    'success', true,
    'webhook_id', v_webhook_id,
    'event_type', p_event_type
  );
end;
$$;

comment on function public.process_webhook_event is 'Logs and processes webhook events from payment providers';

-- ============================================================================
-- 10. Function: Get transaction status
-- ============================================================================

create or replace function public.get_transaction_status(p_transaction_id uuid)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_transaction record;
begin
  select
    t.id,
    t.status,
    t.amount_credits,
    t.commission_credits,
    t.transaction_type,
    t.provider_transaction_id,
    t.provider_payment_intent_id,
    t.provider_error_code,
    t.provider_error_message,
    t.created_at,
    t.completed_at,
    w.id as wallet_id,
    w.balance_credits as current_balance
  into v_transaction
  from public.payment_transactions t
  left join public.wallets w on t.wallet_id = w.id
  where t.id = p_transaction_id and t.user_id = auth.uid();

  if v_transaction.id is null then
    raise exception 'Transaction not found or unauthorized';
  end if;

  return to_jsonb(v_transaction);
end;
$$;

comment on function public.get_transaction_status is 'Get status of a payment transaction';

-- ============================================================================
-- 11. Function: Get user transaction history
-- ============================================================================

create or replace function public.get_user_transaction_history(
  p_user_id uuid,
  p_limit int default 50,
  p_offset int default 0
)
returns table(
  id uuid,
  transaction_type text,
  amount_credits int,
  commission_credits int,
  status text,
  provider_transaction_id text,
  created_at timestamp with time zone,
  completed_at timestamp with time zone
)
language plpgsql
security definer
as $$
begin
  -- Check authorization
  if auth.uid() != p_user_id and not exists (
    select 1 from public.profiles where id = auth.uid() and role = 'admin'
  ) then
    raise exception 'Unauthorized';
  end if;

  return query
  select
    t.id,
    t.transaction_type,
    t.amount_credits,
    t.commission_credits,
    t.status,
    t.provider_transaction_id,
    t.created_at,
    t.completed_at
  from public.payment_transactions t
  where t.user_id = p_user_id
  order by t.created_at desc
  limit p_limit
  offset p_offset;
end;
$$;

comment on function public.get_user_transaction_history is 'Get transaction history for user with pagination';

-- ============================================================================
-- 12. Replace mock functions (keep for backward compatibility)
-- ============================================================================

-- Update mock_wallet_topup to use real payments if provider is active
create or replace function public.mock_wallet_topup(
  p_wallet_id uuid,
  p_amount int,
  p_payment_method_id uuid default null
)
returns jsonb
language plpgsql
security definer
as $$
declare
  v_provider text;
begin
  v_provider := public.get_active_payment_provider();
  
  -- If real provider is active, create payment intent instead
  if v_provider != 'mock' then
    return public.create_payment_intent(p_wallet_id, p_amount, p_payment_method_id);
  end if;
  
  -- Otherwise, use old mock logic (from previous migration)
  declare
    v_user_id uuid;
    v_wallet_type wallet_type;
    v_commission int;
    v_amount_credited int;
    v_transaction_id uuid;
    v_mock_provider_id text;
  begin
    select user_id, wallet_type into v_user_id, v_wallet_type
    from public.wallets
    where id = p_wallet_id;

    if v_user_id is null then
      raise exception 'Wallet not found';
    end if;

    v_commission := public.calculate_commission(p_amount, 'topup', v_wallet_type);
    v_amount_credited := p_amount - v_commission;
    v_mock_provider_id := 'mock_' || gen_random_uuid()::text;

    insert into public.payment_transactions (
      user_id, wallet_id, amount_credits, commission_credits,
      transaction_type, payment_method_id, status, provider_transaction_id, completed_at
    )
    values (
      v_user_id, p_wallet_id, p_amount, v_commission,
      'topup', p_payment_method_id, 'completed', v_mock_provider_id, now()
    )
    returning id into v_transaction_id;

    update public.wallets
    set
      balance_credits = balance_credits + v_amount_credited,
      lifetime_top_up_credits = lifetime_top_up_credits + v_amount_credited,
      updated_at = now()
    where id = p_wallet_id;

    return jsonb_build_object(
      'success', true,
      'transaction_id', v_transaction_id,
      'amount', p_amount,
      'commission', v_commission,
      'amount_credited', v_amount_credited,
      'provider_transaction_id', v_mock_provider_id,
      'provider', 'mock'
    );
  end;
end;
$$;

-- ============================================================================
-- 13. Insert default configuration (test mode)
-- ============================================================================

insert into public.payment_provider_config (provider_name, is_active, test_mode)
values
  ('yookassa', false, true),
  ('stripe', false, true)
on conflict (provider_name) do nothing;

-- ============================================================================
-- 14. Grant execute permissions
-- ============================================================================

grant execute on function public.get_active_payment_provider() to authenticated;
grant execute on function public.create_payment_intent(uuid, int, uuid, text) to authenticated;
grant execute on function public.confirm_payment(uuid, text, text) to authenticated;
grant execute on function public.fail_payment(uuid, text, text) to authenticated;
grant execute on function public.process_webhook_event(text, text, text, jsonb) to anon, authenticated;
grant execute on function public.get_transaction_status(uuid) to authenticated;
grant execute on function public.get_user_transaction_history(uuid, int, int) to authenticated;
